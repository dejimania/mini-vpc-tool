<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VPC Implementation Concepts & Design Decisions</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 900px; margin: 40px auto; padding: 0 20px; line-height: 1.6; }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; border-left: 4px solid #3498db; padding-left: 15px; }
        h3 { color: #7f8c8d; }
        code { background: #ecf0f1; padding: 2px 6px; border-radius: 3px; font-family: monospace; }
        pre { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .concept { background: #e8f4f8; padding: 15px; margin: 15px 0; border-radius: 5px; border-left: 4px solid #3498db; }
        .reason { background: #fff3cd; padding: 15px; margin: 15px 0; border-radius: 5px; border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <h1>VPC Implementation: Concepts & Design Decisions</h1>

    <h2>1. Network Namespaces</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Network namespaces provide isolated network stacks in Linux. Each namespace has its own network interfaces, routing tables, firewall rules, and network configuration.</p>
        <pre>ip netns add ns-vpc1-public</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Isolation:</strong> Each subnet needs complete network isolation, just like AWS VPC subnets. Namespaces provide this without virtual machines.</p>
        <p><strong>Resource Efficiency:</strong> Lightweight compared to VMs - uses same kernel, minimal overhead.</p>
        <p><strong>Real VPC Simulation:</strong> Mimics how cloud providers isolate customer networks at the hypervisor level.</p>
    </div>

    <h2>2. Linux Bridge</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>A Linux bridge acts as a virtual switch, connecting multiple network interfaces at Layer 2. It forwards packets between connected interfaces.</p>
        <pre>ip link add name br-vpc1 type bridge</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Central Router:</strong> The bridge acts as the VPC router, enabling subnet-to-subnet communication within the VPC.</p>
        <p><strong>Scalability:</strong> Can connect unlimited subnets (namespaces) to a single bridge.</p>
        <p><strong>Layer 2 Switching:</strong> Provides efficient packet forwarding without complex routing logic.</p>
    </div>

    <h2>3. Veth Pairs</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Virtual Ethernet pairs are like virtual cables - packets sent to one end appear at the other end. Used to connect namespaces to the host or bridges.</p>
        <pre>ip link add veth-public type veth peer name eth0</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Namespace Connectivity:</strong> Only way to connect isolated namespaces to the outside world or bridges.</p>
        <p><strong>Point-to-Point Link:</strong> Creates a dedicated connection between subnet (namespace) and VPC router (bridge).</p>
        <p><strong>Clean Topology:</strong> One veth pair per subnet keeps the network architecture simple and manageable.</p>
    </div>

    <h2>4. IP Address Assignment Strategy</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Automatic IP assignment using CIDR manipulation:</p>
        <ul>
            <li>Gateway: <code>x.x.x.1</code> (on bridge)</li>
            <li>Host: <code>x.x.x.2</code> (in namespace)</li>
        </ul>
        <pre>gateway=$(echo $cidr | sed 's/\.[0-9]*\//.1/')
host_ip=$(echo $cidr | sed 's/\.[0-9]*\//.2/')</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Predictability:</strong> Consistent IP scheme across all VPCs makes troubleshooting easier.</p>
        <p><strong>Automation:</strong> No manual IP configuration needed - derived from CIDR.</p>
        <p><strong>AWS Convention:</strong> Mirrors AWS VPC behavior where .1 is reserved for the router.</p>
    </div>

    <h2>5. NAT with iptables</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Network Address Translation (NAT) allows private IPs to access the internet by masquerading behind the host's public IP.</p>
        <pre>iptables -t nat -A POSTROUTING -s 10.0.1.0/24 -o eth0 -j MASQUERADE
iptables -A FORWARD -i br-vpc1 -o eth0 -j ACCEPT</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Internet Gateway Simulation:</strong> Replicates AWS Internet Gateway functionality for public subnets.</p>
        <p><strong>MASQUERADE:</strong> Automatically uses the outbound interface's IP, works even with dynamic IPs.</p>
        <p><strong>Stateful Filtering:</strong> ESTABLISHED,RELATED rules allow return traffic while maintaining security.</p>
    </div>

    <h2>6. VPC Peering with Veth Pairs</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Connect two VPC bridges using a veth pair, creating a direct link between isolated VPCs.</p>
        <pre>ip link add peer-vpc1-vpc2 type veth peer name peer-vpc2-vpc1
ip link set peer-vpc1-vpc2 master br-vpc1
ip link set peer-vpc2-vpc1 master br-vpc2</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Direct Connection:</strong> Veth pair creates a dedicated link between VPC bridges, just like AWS VPC peering.</p>
        <p><strong>No Routing Overhead:</strong> Bridges handle forwarding automatically once connected.</p>
        <p><strong>Isolation Maintained:</strong> Only peered VPCs can communicate; others remain isolated.</p>
    </div>

    <h2>7. Security Groups with iptables</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Apply firewall rules inside each namespace using iptables, controlled by JSON policy files.</p>
        <pre>ip netns exec ns-vpc1-public iptables -A INPUT -p tcp --dport 80 -j ACCEPT
ip netns exec ns-vpc1-public iptables -P INPUT DROP</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Per-Subnet Isolation:</strong> Each namespace has independent firewall rules, like AWS security groups.</p>
        <p><strong>Default Deny:</strong> Setting INPUT policy to DROP ensures only explicitly allowed traffic passes.</p>
        <p><strong>JSON Configuration:</strong> Declarative policy files make rules version-controllable and reusable.</p>
    </div>

    <h2>8. Configuration Storage</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Store VPC metadata in simple text files under <code>/var/run/vpcctl/</code>.</p>
        <pre>echo "CIDR=10.0.0.0/16" > /var/run/vpcctl/vpc1.conf
echo "SUBNET_public_CIDR=10.0.1.0/24" >> /var/run/vpcctl/vpc1.conf</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Simplicity:</strong> No database needed - plain text files are easy to read and debug.</p>
        <p><strong>Idempotency:</strong> Check file existence before creating resources to prevent duplicates.</p>
        <p><strong>Cleanup Tracking:</strong> Configuration files list all resources to delete when VPC is removed.</p>
        <p><strong>Volatile Storage:</strong> <code>/var/run</code> is cleared on reboot, preventing stale configurations.</p>
    </div>

    <h2>9. Colored Logging System</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>ANSI color codes provide visual feedback for different log levels.</p>
        <pre>RED='\033[0;31m'
GREEN='\033[0;32m'
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>User Experience:</strong> Colors make it easy to spot errors (red) vs successes (green) at a glance.</p>
        <p><strong>Debugging:</strong> Blue INFO messages show detailed operation steps for troubleshooting.</p>
        <p><strong>Professional Output:</strong> Matches modern CLI tools like kubectl, docker, terraform.</p>
    </div>

    <h2>10. Idempotent Operations</h2>
    <div class="concept">
        <h3>Concept</h3>
        <p>Check if resources exist before creating them; use <code>|| true</code> for cleanup operations.</p>
        <pre>if [[ -f "$VPC_DIR/$vpc_name.conf" ]]; then
    log_error "VPC already exists"
    return 1
fi

ip netns del "$ns_name" 2>/dev/null || true</pre>
    </div>
    <div class="reason">
        <h3>Why This Approach</h3>
        <p><strong>Reliability:</strong> Running the same command twice doesn't break the system.</p>
        <p><strong>Safe Cleanup:</strong> Deletion commands don't fail if resources are already gone.</p>
        <p><strong>Infrastructure as Code:</strong> Enables automation and scripting without error handling complexity.</p>
    </div>

    <h2>Architecture Summary</h2>
    <div class="concept">
        <p><strong>VPC = Bridge</strong> (central router)</p>
        <p><strong>Subnet = Namespace</strong> (isolated network environment)</p>
        <p><strong>Connection = Veth Pair</strong> (virtual cable)</p>
        <p><strong>Internet Gateway = NAT + iptables</strong> (masquerading)</p>
        <p><strong>Security Group = Namespace iptables</strong> (per-subnet firewall)</p>
        <p><strong>VPC Peering = Bridge-to-Bridge Veth</strong> (cross-VPC link)</p>
    </div>

    <div class="reason">
        <h3>Overall Design Philosophy</h3>
        <p><strong>Minimal Dependencies:</strong> Uses only standard Linux tools (ip, iptables) - no external packages.</p>
        <p><strong>Cloud-Native Concepts:</strong> Directly maps to AWS VPC primitives for learning and understanding.</p>
        <p><strong>Production-Ready Patterns:</strong> Idempotency, logging, error handling, and cleanup mirror real infrastructure tools.</p>
        <p><strong>Educational Value:</strong> Exposes the underlying networking that cloud providers abstract away.</p>
    </div>
</body>
</html>
